{
		"language": "Solidity",
		"sources": {
			"Booloot.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n// Chainlink VRF V2.5 Imports (Direct Funding, Native Token Payment)\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {VRFV2PlusWrapperConsumerBase} from \"@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol\"; // For Direct Funding\nimport {VRFV2PlusClient} from \"@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol\";\n\n/**\n * @title Booloot Game Contract - Secure VRF Only\n * @author Aratta Labs\n * @notice A mystery box game utilizing Chainlink VRF for secure, verifiable randomness. Winnings are stored for players to claim manually.\n * @dev The contract exclusively uses the secure 'play' function. The 'rng' function remains for potential off-chain testing/simulation but is not used internally for prize selection.\n * @custom:version 9\n * @custom:emoji ðŸ“Š\n * @custom:security-contact atenyun@gmail.com\n */\ncontract Booloot is Pausable, ReentrancyGuard, VRFV2PlusWrapperConsumerBase, ConfirmedOwner {\n    // =============================\n    //          Custom Errors\n    // =============================\n\n    /// @dev Thrown when the payment sent is less than the required game fee plus VRF fee.\n    error InsufficientPayment(uint256 providedAmount, uint256 requiredFee);\n    /// @dev Thrown if an internal error occurs when trying to select a prize index. (Legacy error)\n    error PrizeNotFound(uint256 attempts);\n    /// @dev Thrown when a VRF request is made while a previous one is still pending fulfillment.\n    error RequestAlreadyPending();\n    /// @dev Thrown if the VRF fulfillment callback returns an unexpected Request ID.\n    error VRFRequestMismatch(uint256 providedRequestId);\n    /// @dev Thrown if the contract's current ETH balance cannot cover the maximum possible prize plus the game fee.\n    error InsufficientContractBalance(uint256 required, uint256 current);\n\n    // =============================\n    //             Events\n    // =============================\n\n    /// @notice Emitted when a player successfully wins and receives a prize.\n    /// @param player The address of the player who won.\n    /// @param prizeAmount The amount of the prize won in wei.\n    /// @param timestamp The time the event occurred.\n    event Win(address indexed player, uint256 prizeAmount, uint256 timestamp);\n    /// @notice Emitted when the owner successfully withdraws funds from the contract.\n    /// @param recipient The address that received the withdrawn funds (contract owner).\n    /// @param amount The amount of ETH withdrawn in wei.\n    /// @param timestamp The time the event occurred.\n    event Withdrawal(address indexed recipient, uint256 amount, uint256 timestamp);\n    /// @notice Emitted when the contract owner updates the available prize pool array.\n    /// @param newPrizes The array of new prize amounts.\n    /// @param timestamp The time the event occurred.\n    event PrizesUpdated(uint256[] newPrizes, uint256 timestamp);\n\n    // VRF Events\n    /// @notice Emitted immediately after a VRF request is successfully submitted to the Chainlink network.\n    /// @param requestId The unique ID assigned to the randomness request.\n    /// @param requester The address of the player who paid for and initiated the request.\n    /// @param paidAmount The exact amount of native token (STT) paid to the VRF Wrapper.\n    event VRFRandomnessRequested(uint256 indexed requestId, address indexed requester, uint256 paidAmount);\n    /// @notice Emitted when the VRF callback successfully returns the random number and the player is paid.\n    /// @param requestId The unique ID of the request that was fulfilled.\n    /// @param prizeAmount The final prize amount awarded to the player.\n    event VRFRandomnessFulfilled(uint256 indexed requestId, uint256 prizeAmount);\n\n    // =============================\n    //         State Variables\n    // =============================\n\n    /// @notice The fixed maximum prize amount (4 ETH), used for ensuring sufficient contract reserve before a game starts.\n    uint256 public constant MAX_PRIZE_RESERVE_ETH = 4 ether;\n\n    /// @notice The fixed fee (in wei) required from the player to play a single round of the game.\n    uint256 public fee = 1 ether;\n\n    /// @notice An array of fixed prizes available in the game, in wei. This pool is infinitely reusable.\n    uint256[] public prizes = [\n        0.1 ether,\n        0.1 ether,\n        0.1 ether,\n        0.15 ether,\n        0.2 ether,\n        0.2 ether,\n        0.25 ether,\n        0.25 ether,\n        0.3 ether,\n        0.4 ether,\n        0.4 ether,\n        0.5 ether,\n        0.5 ether,\n        0.6 ether,\n        0.7 ether,\n        0.8 ether,\n        0.9 ether,\n        1.1 ether,\n        1.2 ether,\n        1.5 ether,\n        2 ether,\n        2.5 ether,\n        3.1 ether,\n        3.3 ether,\n        4 ether\n    ];\n\n    /// @notice The total number of unique players who have participated in the game.\n    uint256 public uniquePlayerCount;\n\n    /// @notice A mapping from player addresses to their total accumulated winnings (in wei).\n    mapping(address => uint256) public wins;\n\n    /// @notice A mapping from player addresses to the total number of games they have played.\n    mapping(address => uint256) public players;\n\n    /// @notice An array containing the addresses of all unique players who have played.\n    address[] public allPlayers;\n\n    /// @notice A mapping to quickly check if a player's address is already registered in the `allPlayers` array.\n    mapping(address => bool) public isPlayerRegistered;\n\n    /// @notice A mapping from player addresses to the total accumulated winnings (prize + refund) they can claim.\n    mapping(address => uint256) public unclaimedWinnings;\n\n    // Structs\n    /// @notice Data structure to represent a player's statistics for leaderboard purposes.\n    struct PlayerData {\n        /// @notice The player's unique wallet address.\n        address player;\n        /// @notice The total accumulated winnings (in wei) of the player.\n        uint256 wins;\n        /// @notice The total number of times the player has played the game.\n        uint256 played;\n    }\n\n    // =============================\n    //         Chainlink VRF V2+\n    // =============================\n\n    /// @notice The maximum gas limit the VRF Wrapper can use when calling `fulfillRandomWords`.\n    uint32 public constant VRF_CALLBACK_GAS_LIMIT = 2_100_000;\n    /// @notice The number of block confirmations the oracle network waits for before fulfilling the request.\n    uint16 public constant VRF_REQUEST_CONFIRMATIONS = 3;\n    /// @notice The number of random words requested from VRF. One word is used for the prize index.\n    uint32 public constant VRF_NUM_WORDS = 3;\n\n    /// @notice The Request ID of the most recent secure VRF randomness request.\n    uint256 public latestRequestId;\n\n    /// @notice Status flag indicating if the latest randomness request has been fulfilled.\n    bool public fulfilled = true;\n\n    /// @notice Maps a VRF request ID to the address of the player who made the request.\n    mapping(uint256 => address) public requestToPlayer;\n\n    /// @notice Maps a VRF request ID to the overpayment refund amount owed to the player.\n    mapping(uint256 => uint256) public requestRefunds;\n\n    /// @notice Stores the latest random word(s) received from the Chainlink VRF fulfillment callback.\n    uint256[] public latestRandomWord;\n\n    // =============================\n    //         Constructor\n    // =============================\n\n    /**\n     * @notice Initializes the contract with the VRF V2+ Wrapper address.\n     * @param wrapper The address of the Protofire Chainlink VRF V2+ Wrapper contract.\n     */\n    constructor(address wrapper) payable ConfirmedOwner(msg.sender) VRFV2PlusWrapperConsumerBase(wrapper) {}\n\n    // =============================\n    //          Management\n    // =============================\n\n    /**\n     * @notice Updates the fixed fee required to play the game.\n     * @dev Only the contract owner can call this function.\n     * @param _fee The new fee amount in wei.\n     */\n    function updateFee(uint256 _fee) public onlyOwner {\n        fee = _fee;\n    }\n\n    /**\n     * @notice Updates the array of fixed prizes for the game.\n     * @dev Only the contract owner can call this function.\n     * @param _prizes An array containing the new prize amounts in wei.\n     */\n    function updatePrizes(uint256[] memory _prizes) public onlyOwner nonReentrant {\n        prizes = _prizes;\n        emit PrizesUpdated(_prizes, block.timestamp);\n    }\n\n    // =============================\n    //            Views\n    // =============================\n\n    /**\n     * @notice Retrieves the current price required to pay the Chainlink VRF oracle.\n     * @dev This should be used to calculate the total required payment (game fee + VRF fee) for `play()`.\n     * @return The required VRF price in native token (STT in Somnia).\n     */\n    function getVRFRequestPrice() public view returns (uint256) {\n        return i_vrfV2PlusWrapper.calculateRequestPriceNative(VRF_CALLBACK_GAS_LIMIT, VRF_NUM_WORDS);\n    }\n\n    /**\n     * @notice Retrieves the entire array of fixed prizes currently available in the pool.\n     * @return An array containing all prize amounts in wei.\n     */\n    function getAllPrizes() external view returns (uint256[] memory) {\n        return prizes;\n    }\n\n    /**\n     * @notice Retrieves a paginated batch of player addresses and their statistics for leaderboard construction.\n     * @param startIndex The starting index for the batch.\n     * @param batchSize The number of players to return in the batch.\n     * @return A memory array containing the PlayerData struct for the requested batch.\n     */\n    function getPlayersBatch(uint256 startIndex, uint256 batchSize) external view returns (PlayerData[] memory) {\n        uint256 endIndex = startIndex + batchSize;\n        if (endIndex > allPlayers.length) endIndex = allPlayers.length;\n\n        uint256 resultLength = endIndex - startIndex;\n        PlayerData[] memory batch = new PlayerData[](resultLength);\n\n        for (uint256 i = startIndex; i < endIndex; i++) {\n            batch[i - startIndex] = PlayerData({player: allPlayers[i], wins: wins[allPlayers[i]], played: players[allPlayers[i]]});\n        }\n        return batch;\n    }\n\n    /**\n     * @notice Generates a predictable number based on block data, sender address, and a nonce.\n     * @dev CRITICAL VULNERABILITY: This function remains for testing/simulation. It is highly susceptible to miner manipulation and front-running. DO NOT USE INTERNALLY FOR PRIZES.\n     * @param len The upper bound (non-inclusive) for the random number (e.g., prizes.length).\n     * @param nonce An additional value to prevent simple replay attacks.\n     * @return The pseudo-random number, which can be manipulated.\n     */\n    function rng(uint256 len, uint256 nonce) public view returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender, nonce))) % len;\n    }\n\n    /**\n     * @notice Returns the modulo of a random word by the prizes length. Used for testing the prize selection logic.\n     * @param randomWords A simulated random word.\n     * @return The index into the prize array.\n     */\n    function testTest(uint256 randomWords) public view returns (uint256) {\n        return randomWords % prizes.length;\n    }\n\n    // =============================\n    //         Game Logic (Secure VRF)\n    // =============================\n\n    /**\n     * @notice Returns the status of the latest secure VRF request.\n     * @return requestId The unique ID of the last request.\n     * @return isPending True if the request has been submitted but not yet fulfilled.\n     * @return isFulfilled True if the last request has successfully been fulfilled.\n     */\n    function getRequestStatus() external view returns (uint256 requestId, bool isPending, bool isFulfilled) {\n        return (latestRequestId, latestRequestId != 0 && !fulfilled, fulfilled);\n    }\n\n    /**\n     * @notice Returns the random word(s) from the most recently fulfilled VRF request.\n     * @dev Requires that a request has already been successfully fulfilled (`fulfilled == true`).\n     * @return An array containing the random word(s).\n     */\n    function getLatestRandomWord() external view returns (uint256[] memory) {\n        require(fulfilled, \"No fulfilled request yet\");\n        return latestRandomWord;\n    }\n\n    /**\n     * @notice Requests a secure, verifiable random number from Chainlink VRF.\n     * @dev Player must pay the game fee PLUS the current VRF fee. This function initiates an asynchronous process. The prize is awarded in `fulfillRandomWords`.\n     * @return The request ID for tracking the randomness fulfillment.\n     */\n    function play() external payable nonReentrant whenNotPaused returns (uint256) {\n        address player = _msgSender();\n\n        // Enforce financial reserve check\n        uint256 requiredReserve = MAX_PRIZE_RESERVE_ETH + fee;\n        if (address(this).balance < requiredReserve) {\n            revert InsufficientContractBalance(requiredReserve, address(this).balance);\n        }\n\n        // 1. Block overlapping VRF requests\n        if (latestRequestId != 0 && !fulfilled) revert RequestAlreadyPending();\n\n        // 2. Compute total required fee (Game Fee + VRF Fee)\n        uint256 vrfPrice = getVRFRequestPrice();\n        uint256 totalRequiredPayment = fee + vrfPrice;\n\n        // 3. Check for sufficient payment\n        if (msg.value < totalRequiredPayment) {\n            revert InsufficientPayment(msg.value, totalRequiredPayment);\n        }\n\n        // 4. Calculate overpayment refund amount (if any)\n        uint256 overpaymentRefund = msg.value - totalRequiredPayment;\n\n        // 5. Signal native payment to the wrapper\n        VRFV2PlusClient.ExtraArgsV1 memory extraArgs = VRFV2PlusClient.ExtraArgsV1({nativePayment: true});\n        bytes memory args = VRFV2PlusClient._argsToBytes(extraArgs);\n\n        // 6. Submit request (uses native STT)\n        (uint256 requestId, uint256 paid) = requestRandomnessPayInNative(VRF_CALLBACK_GAS_LIMIT, VRF_REQUEST_CONFIRMATIONS, VRF_NUM_WORDS, args);\n\n        // 7. Update state for request tracking - REFUND STORAGE RESTORED\n        latestRequestId = requestId;\n        fulfilled = false;\n        requestToPlayer[requestId] = player;\n        requestRefunds[requestId] = overpaymentRefund; // Store refund to be processed after prize is awarded\n\n        players[player] += 1;\n\n        if (!isPlayerRegistered[player]) {\n            allPlayers.push(player);\n            isPlayerRegistered[player] = true;\n            uniquePlayerCount++;\n        }\n\n        emit VRFRandomnessRequested(requestId, _msgSender(), paid);\n\n        return requestId;\n    }\n\n    /**\n     * @notice Called by the VRF Wrapper after the random word is generated.\n     * @dev This is the crucial callback function that verifies the VRF result, selects the prize, pays the player, updates stats, and saves winnings for later claiming.\n     * @dev Note: https://docs.chain.link/vrf/v2-5/security#fulfillrandomwords-must-not-revert:~:text=If%20your%20fulfillRandomWords,Automation%20Node.\n     * @param requestId The ID of the VRF request that was fulfilled.\n     * @param randomWords The array of random numbers (must be length of VRF_NUM_WORDS).\n     */\n    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n        // 1. Validation (Cleaned up and precise validation restored)\n        require(randomWords.length == VRF_NUM_WORDS, \"Incorrect word count\");\n        require(requestId == latestRequestId, \"VRFRequestMismatch\");\n\n        address player = requestToPlayer[requestId];\n        uint256 overpaymentRefund = requestRefunds[requestId];\n\n        // 2. Select prize using the random word\n        uint256 prizeIndex = randomWords[0] % prizes.length;\n        uint256 prizeAmount = prizes[prizeIndex];\n\n        // 3. Instead of immediate transfer, add prize and refund to unclaimed winnings\n        uint256 totalPayout = prizeAmount + overpaymentRefund;\n        unclaimedWinnings[player] += totalPayout;\n\n        // 4. Update player stats and registration\n        // Note: 'wins' tracks the gross prize amount won, regardless of when it is claimed.\n        wins[player] += totalPayout;\n\n        // 5. Clean up VRF request state - RESTORED\n        latestRandomWord = randomWords;\n        // delete requestToPlayer[requestId];\n        // delete requestRefunds[requestId];\n        fulfilled = true;\n\n        emit Win(player, prizeAmount, block.timestamp);\n        emit VRFRandomnessFulfilled(requestId, prizes[prizeIndex]);\n    }\n\n    // =============================\n    //          Claiming\n    // =============================\n\n    /**\n     * @notice Allows a player to withdraw their accumulated unclaimed winnings and overpayment refunds.\n     * @dev Uses a reentrancy guard. The player's balance is reset to zero before the transfer to prevent reentrancy attacks.\n     */\n    function claimWinnings() public nonReentrant {\n        uint256 amount = unclaimedWinnings[msg.sender];\n        require(amount > 0, \"No unclaimed winnings to withdraw\");\n\n        // Set amount to zero BEFORE sending funds\n        unclaimedWinnings[msg.sender] = 0;\n\n        // Send funds to the player\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n    }\n\n    /**\n     * @notice Transfers the entire contract's ETH balance to the contract owner.\n     * @dev Only the contract owner (`ConfirmedOwner`) can call this function. Uses a reentrancy guard.\n     */\n    function withdrawAll() public onlyOwner nonReentrant {\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"No balance\");\n        (bool success, ) = payable(owner()).call{value: amount}(\"\");\n        require(success, \"Failed to withdraw\");\n\n        emit Withdrawal(owner(), amount, block.timestamp);\n    }\n\n    /**\n     * @notice Pauses the secure game playing operation (`play`).\n     * @dev Only the contract owner can call this function.\n     */\n    function pausePlaying() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpauses the secure game playing operation (`play`).\n     * @dev Only the contract owner can call this function.\n     */\n    function unpausePlaying() public onlyOwner {\n        _unpause();\n    }\n}\n"
			},
			"@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// End consumer library.\nlibrary VRFV2PlusClient {\n  // extraArgs will evolve to support new features\n  bytes4 public constant EXTRA_ARGS_V1_TAG = bytes4(keccak256(\"VRF ExtraArgsV1\"));\n\n  struct ExtraArgsV1 {\n    bool nativePayment;\n  }\n\n  struct RandomWordsRequest {\n    bytes32 keyHash;\n    uint256 subId;\n    uint16 requestConfirmations;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    bytes extraArgs;\n  }\n\n  function _argsToBytes(\n    ExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
			},
			"@chainlink/contracts/src/v0.8/vrf/dev/VRFV2PlusWrapperConsumerBase.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LinkTokenInterface} from \"../../shared/interfaces/LinkTokenInterface.sol\";\nimport {IVRFV2PlusWrapper} from \"./interfaces/IVRFV2PlusWrapper.sol\";\n\n/**\n *\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2+ requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2+ subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2PlusWrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK or ether to make the request, otherwise requests will revert. To request randomness,\n * @dev call the 'requestRandomWords' function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2PlusWrapperConsumerBase {\n  error OnlyVRFWrapperCanFulfill(address have, address want);\n\n  LinkTokenInterface internal immutable i_linkToken;\n  IVRFV2PlusWrapper public immutable i_vrfV2PlusWrapper;\n\n  /**\n   * @param _vrfV2PlusWrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(\n    address _vrfV2PlusWrapper\n  ) {\n    IVRFV2PlusWrapper vrfV2PlusWrapper = IVRFV2PlusWrapper(_vrfV2PlusWrapper);\n\n    i_linkToken = LinkTokenInterface(vrfV2PlusWrapper.link());\n    i_vrfV2PlusWrapper = vrfV2PlusWrapper;\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2+ wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2+ request ID of the newly created randomness request.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords,\n    bytes memory extraArgs\n  ) internal returns (uint256 requestId, uint256 reqPrice) {\n    reqPrice = i_vrfV2PlusWrapper.calculateRequestPrice(_callbackGasLimit, _numWords);\n    i_linkToken.transferAndCall(\n      address(i_vrfV2PlusWrapper), reqPrice, abi.encode(_callbackGasLimit, _requestConfirmations, _numWords, extraArgs)\n    );\n    return (i_vrfV2PlusWrapper.lastRequestId(), reqPrice);\n  }\n\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function requestRandomnessPayInNative(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords,\n    bytes memory extraArgs\n  ) internal returns (uint256 requestId, uint256 requestPrice) {\n    requestPrice = i_vrfV2PlusWrapper.calculateRequestPriceNative(_callbackGasLimit, _numWords);\n    return (\n      i_vrfV2PlusWrapper.requestRandomWordsInNative{value: requestPrice}(\n        _callbackGasLimit, _requestConfirmations, _numWords, extraArgs\n      ),\n      requestPrice\n    );\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    address vrfWrapperAddr = address(i_vrfV2PlusWrapper);\n    if (msg.sender != vrfWrapperAddr) {\n      revert OnlyVRFWrapperCanFulfill(msg.sender, vrfWrapperAddr);\n    }\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n\n  /// @notice getBalance returns the native balance of the consumer contract\n  function getBalance() public view returns (uint256) {\n    return address(this).balance;\n  }\n\n  /// @notice getLinkToken returns the link token contract\n  function getLinkToken() public view returns (LinkTokenInterface) {\n    return i_linkToken;\n  }\n}\n"
			},
			"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(\n    address newOwner\n  ) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
			},
			"@openzeppelin/contracts/utils/Pausable.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
			},
			"@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
			},
			"@openzeppelin/contracts/utils/Context.sol": {
				"content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
			},
			"@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFV2PlusWrapper.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IVRFV2PlusWrapper {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit, uint32 _numWords) external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request in native with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   */\n  function calculateRequestPriceNative(uint32 _callbackGasLimit, uint32 _numWords) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(\n    uint32 _callbackGasLimit,\n    uint32 _numWords,\n    uint256 _requestGasPriceWei\n  ) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request in native with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _numWords is the number of words to request.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPriceNative(\n    uint32 _callbackGasLimit,\n    uint32 _numWords,\n    uint256 _requestGasPriceWei\n  ) external view returns (uint256);\n\n  /**\n   * @notice Requests randomness from the VRF V2 wrapper, paying in native token.\n   *\n   * @param _callbackGasLimit is the gas limit for the request.\n   * @param _requestConfirmations number of request confirmations to wait before serving a request.\n   * @param _numWords is the number of words to request.\n   */\n  function requestRandomWordsInNative(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords,\n    bytes calldata extraArgs\n  ) external payable returns (uint256 requestId);\n\n  function link() external view returns (address);\n  function linkNativeFeed() external view returns (address);\n}\n"
			},
			"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(\n    address owner\n  ) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
			},
			"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(\n    address to\n  ) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(\n    address to\n  ) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
			},
			"@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
				"content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(\n    address recipient\n  ) external;\n\n  function acceptOwnership() external;\n}\n"
			}
		},
		"settings": {
			"optimizer": {
				"enabled": false,
				"runs": 200
			},
			"outputSelection": {
				"*": {
					"": [
						"ast"
					],
					"*": [
						"abi",
						"metadata",
						"devdoc",
						"userdoc",
						"storageLayout",
						"evm.legacyAssembly",
						"evm.bytecode",
						"evm.deployedBytecode",
						"evm.methodIdentifiers",
						"evm.gasEstimates",
						"evm.assembly"
					]
				}
			},
			"remappings": []
		}
	}